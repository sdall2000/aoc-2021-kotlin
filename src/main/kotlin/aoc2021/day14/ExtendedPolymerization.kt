package aoc2021.day14

// Key insight, from https://github.com/jonathanpaulson/AdventOfCode.
// Once we convert the template string to the character pair groupings, the order of the pairs in the
// larger template string no longer matter.  At that point we can just count how many of each pair there are after
// each iteration.  We don't need to keep building a corresponding string (which will eventually overflow memory).

class ExtendedPolymerization {
    fun maxMinusMinCount(lines: List<String>, steps: Int): Long {
        val template = lines[0].trim()

        val pairInsertionRules = HashMap<String, String>()

        lines.forEachIndexed { index, line ->
            if (index >= 2) {
                val (pair, ch) = line.split(" -> ")

                pairInsertionRules[pair] = ch
            }
        }

        // Build a map of letter pairs to counts.  So an input template of "NNCB" (our sample data)
        // Would contain pairs NN, NC, CB, each with a count of 1.
        var mapPairToCount =
            template
                // Take two strings at a time from the template.
                .windowed(2)
                // Build a list out of all the windowed results.
                .map { it }
                // Group by pairs
                .groupingBy { it }
                // Map the pairs to their corresponding count.
                .eachCount()
                // With the larger number of iterations, we may run into counts that exceed the int value.  So convert to longs.
                // Credit to https://todd.ginsberg.com/post/advent-of-code/2021/day14/
                .mapValues { it.value.toLong() }
                // We need to be able to modify the map
                .toMutableMap()

        repeat(steps) {
            // Create a backing store to prevent concurrent modification exceptions.
            val backingMapPairToCount = HashMap<String, Long>()

            mapPairToCount.forEach { (pair, count) ->
                // Get the character that is generated by this pair, per the pair insertion rules (e.g., "CB" -> "H")
                val ruleResultChar = pairInsertionRules[pair]!!

                // Now build the two new pairs that include the ruleResultChar (e.g., "CB" -> "CH", "HB")
                val pair1 = pair[0] + ruleResultChar
                val pair2 = ruleResultChar + pair[1]

                backingMapPairToCount[pair1] = backingMapPairToCount.getOrDefault(pair1, 0) + count
                backingMapPairToCount[pair2] = backingMapPairToCount.getOrDefault(pair2, 0) + count
            }

            mapPairToCount = backingMapPairToCount
        }

        // We have the pair counts, now calculate the individual character counts.

        val mapCharToCount = HashMap<Char, Long>()

        // First count all of the first character occurrences only in the pair.
        mapPairToCount.forEach { (pair, count) ->
            val c1 = pair[0]

            mapCharToCount[c1] = mapCharToCount.getOrDefault(c1, 0) + count
        }

        // Finally, add the very last character to the count.
        val lastChar = template.last()

        mapCharToCount.putIfAbsent(lastChar, 0)
        mapCharToCount[lastChar] = mapCharToCount.getOrDefault(lastChar, 0) + 1

        // Return the max number of occurrences minus the least.
        return mapCharToCount.values.maxOf {
            it
        } - mapCharToCount.values.minOf { it }
    }
}
